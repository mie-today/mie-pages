/**
 * Google Apps Script OAuth Backend for Mie Dashboard
 * 
 * This script handles:
 * 1. Exchanging authorization codes for tokens (with refresh token)
 * 2. Refreshing access tokens when they expire
 * 3. Securely storing refresh tokens
 * 
 * DEPLOYMENT INFO:
 * - Deployment ID: AKfycbzgECqrcoTeijkWFgbUwRjGMYGoJOorx9zCs_dvJbVrhrj-FvTogYsfjKvmdAbwAf7y
 * - Web App URL: https://script.google.com/macros/s/AKfycbzgECqrcoTeijkWFgbUwRjGMYGoJOorx9zCs_dvJbVrhrj-FvTogYsfjKvmdAbwAf7y/exec
 * 
 * REQUIRED SCRIPT PROPERTIES (Settings â†’ Script Properties):
 * - CLIENT_ID: 514922143683-ja02ef5sm7ppsv79l216l5c18tlvtmg5.apps.googleusercontent.com
 * - CLIENT_SECRET: [YOU NEED TO ADD THIS - Get it from Google Cloud Console]
 * 
 * TO ADD CLIENT_SECRET:
 * 1. Click the gear icon (Project Settings) in the left sidebar
 * 2. Scroll down to "Script Properties"
 * 3. Click "Add script property"
 * 4. Property: CLIENT_SECRET
 * 5. Value: [Paste your client secret from Google Cloud Console]
 * 6. Click "Save script properties"
 */

// Get credentials from Script Properties (secure storage)
const CLIENT_ID = PropertiesService.getScriptProperties().getProperty('CLIENT_ID');
const CLIENT_SECRET = PropertiesService.getScriptProperties().getProperty('CLIENT_SECRET');

/**
 * Main entry point for all POST requests
 */
function doPost(e) {
  try {
    // Log incoming request for debugging
    Logger.log('Received POST request');
    Logger.log('Action: ' + e.parameter.action);
    
    const params = JSON.parse(e.postData.contents);
    const action = e.parameter.action;
    
    // Verify CLIENT_SECRET is configured
    if (!CLIENT_SECRET) {
      Logger.log('ERROR: CLIENT_SECRET not configured in Script Properties!');
      return createErrorResponse('Server configuration error: CLIENT_SECRET not set');
    }
    
    if (action === 'exchangeCode') {
      return exchangeCodeForTokens(params);
    } else if (action === 'refreshToken') {
      return refreshAccessToken(params);
    }
    
    return createErrorResponse('Invalid action: ' + action);
  } catch (error) {
    Logger.log('Error in doPost: ' + error.toString());
    Logger.log('Stack trace: ' + error.stack);
    return createErrorResponse(error.toString());
  }
}

/**
 * Handle GET requests (for testing and CORS preflight)
 */
function doGet(e) {
  const action = e.parameter.action;
  
  if (action === 'test') {
    // Test endpoint to verify configuration
    const hasClientId = !!CLIENT_ID;
    const hasClientSecret = !!CLIENT_SECRET;
    
    return ContentService.createTextOutput(JSON.stringify({
      status: 'OAuth Backend Server Running',
      deployment_id: 'AKfycbzgECqrcoTeijkWFgbUwRjGMYGoJOorx9zCs_dvJbVrhrj-FvTogYsfjKvmdAbwAf7y',
      client_id_configured: hasClientId,
      client_secret_configured: hasClientSecret,
      client_id: hasClientId ? CLIENT_ID.substring(0, 20) + '...' : 'NOT SET',
      warning: !hasClientSecret ? 'CLIENT_SECRET not configured in Script Properties!' : null
    }, null, 2))
      .setMimeType(ContentService.MimeType.JSON)
      .setHeader('Access-Control-Allow-Origin', '*');
  }
  
  return ContentService.createTextOutput('Mie OAuth Backend Server - Running\nDeployment ID: AKfycbzgECqrcoTeijkWFgbUwRjGMYGoJOorx9zCs_dvJbVrhrj-FvTogYsfjKvmdAbwAf7y')
    .setMimeType(ContentService.MimeType.TEXT);
}

/**
 * Exchange authorization code for access token and refresh token
 */
function exchangeCodeForTokens(params) {
  try {
    Logger.log('Starting token exchange...');
    
    const code = params.code;
    const redirectUri = params.redirect_uri;
    
    if (!code || !redirectUri) {
      Logger.log('Missing required parameters');
      return createErrorResponse('Missing code or redirect_uri');
    }
    
    Logger.log('Code received: ' + code.substring(0, 20) + '...');
    Logger.log('Redirect URI: ' + redirectUri);
    
    // Exchange code for tokens
    const tokenUrl = 'https://oauth2.googleapis.com/token';
    const payload = {
      code: code,
      client_id: CLIENT_ID,
      client_secret: CLIENT_SECRET,
      redirect_uri: redirectUri,
      grant_type: 'authorization_code'
    };
    
    const options = {
      method: 'post',
      contentType: 'application/x-www-form-urlencoded',
      payload: payload,
      muteHttpExceptions: true
    };
    
    Logger.log('Sending token exchange request to Google...');
    const response = UrlFetchApp.fetch(tokenUrl, options);
    const responseCode = response.getResponseCode();
    const responseData = JSON.parse(response.getContentText());
    
    Logger.log('Response code: ' + responseCode);
    
    if (responseCode !== 200) {
      Logger.log('Token exchange failed: ' + JSON.stringify(responseData));
      return createErrorResponse('Token exchange failed: ' + (responseData.error_description || responseData.error));
    }
    
    Logger.log('Token exchange successful!');
    Logger.log('Access token received: ' + (responseData.access_token ? 'YES' : 'NO'));
    Logger.log('Refresh token received: ' + (responseData.refresh_token ? 'YES' : 'NO'));
    
    // Store refresh token securely (using user's email as key)
    if (responseData.refresh_token) {
      const userEmail = getUserEmailFromToken(responseData.access_token);
      if (userEmail) {
        storeRefreshToken(userEmail, responseData.refresh_token);
        Logger.log('Refresh token stored for user: ' + userEmail);
      } else {
        Logger.log('Warning: Could not get user email, refresh token not stored');
      }
    }
    
    return createSuccessResponse(responseData);
    
  } catch (error) {
    Logger.log('Error exchanging code: ' + error.toString());
    Logger.log('Stack trace: ' + error.stack);
    return createErrorResponse(error.toString());
  }
}

/**
 * Refresh an expired access token using refresh token
 */
function refreshAccessToken(params) {
  try {
    Logger.log('Starting token refresh...');
    
    const refreshToken = params.refresh_token;
    
    if (!refreshToken) {
      Logger.log('Missing refresh token');
      return createErrorResponse('Missing refresh_token');
    }
    
    Logger.log('Refresh token received: ' + refreshToken.substring(0, 20) + '...');
    
    const tokenUrl = 'https://oauth2.googleapis.com/token';
    const payload = {
      refresh_token: refreshToken,
      client_id: CLIENT_ID,
      client_secret: CLIENT_SECRET,
      grant_type: 'refresh_token'
    };
    
    const options = {
      method: 'post',
      contentType: 'application/x-www-form-urlencoded',
      payload: payload,
      muteHttpExceptions: true
    };
    
    Logger.log('Sending refresh request to Google...');
    const response = UrlFetchApp.fetch(tokenUrl, options);
    const responseCode = response.getResponseCode();
    const responseData = JSON.parse(response.getContentText());
    
    Logger.log('Response code: ' + responseCode);
    
    if (responseCode !== 200) {
      Logger.log('Token refresh failed: ' + JSON.stringify(responseData));
      return createErrorResponse('Token refresh failed: ' + (responseData.error_description || responseData.error));
    }
    
    Logger.log('Token refresh successful!');
    Logger.log('New access token received: ' + (responseData.access_token ? 'YES' : 'NO'));
    
    return createSuccessResponse(responseData);
    
  } catch (error) {
    Logger.log('Error refreshing token: ' + error.toString());
    Logger.log('Stack trace: ' + error.stack);
    return createErrorResponse(error.toString());
  }
}

/**
 * Store refresh token in Script Properties (encrypted storage)
 */
function storeRefreshToken(userEmail, refreshToken) {
  try {
    const userProperties = PropertiesService.getUserProperties();
    const key = 'refresh_token_' + Utilities.base64Encode(userEmail);
    userProperties.setProperty(key, refreshToken);
    Logger.log('Stored refresh token for: ' + userEmail);
  } catch (error) {
    Logger.log('Error storing refresh token: ' + error.toString());
  }
}

/**
 * Retrieve refresh token from storage
 */
function getRefreshToken(userEmail) {
  try {
    const userProperties = PropertiesService.getUserProperties();
    const key = 'refresh_token_' + Utilities.base64Encode(userEmail);
    return userProperties.getProperty(key);
  } catch (error) {
    Logger.log('Error retrieving refresh token: ' + error.toString());
    return null;
  }
}

/**
 * Get user email from access token
 */
function getUserEmailFromToken(accessToken) {
  try {
    const options = {
      headers: {
        'Authorization': 'Bearer ' + accessToken
      },
      muteHttpExceptions: true
    };
    
    const response = UrlFetchApp.fetch('https://www.googleapis.com/oauth2/v2/userinfo', options);
    
    if (response.getResponseCode() === 200) {
      const data = JSON.parse(response.getContentText());
      return data.email;
    }
    
    return null;
  } catch (error) {
    Logger.log('Error getting user email: ' + error.toString());
    return null;
  }
}

/**
 * Create success JSON response with CORS headers
 */
function createSuccessResponse(data) {
  return ContentService
    .createTextOutput(JSON.stringify(data))
    .setMimeType(ContentService.MimeType.JSON)
    .setHeader('Access-Control-Allow-Origin', '*')
    .setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')
    .setHeader('Access-Control-Allow-Headers', 'Content-Type');
}

/**
 * Create error JSON response with CORS headers
 */
function createErrorResponse(message) {
  const errorResponse = {
    error: true,
    message: message
  };
  
  Logger.log('Returning error response: ' + message);
  
  return ContentService
    .createTextOutput(JSON.stringify(errorResponse))
    .setMimeType(ContentService.MimeType.JSON)
    .setHeader('Access-Control-Allow-Origin', '*')
    .setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')
    .setHeader('Access-Control-Allow-Headers', 'Content-Type');
}

/**
 * Handle OPTIONS requests for CORS preflight
 */
function doOptions(e) {
  return ContentService
    .createTextOutput('')
    .setMimeType(ContentService.MimeType.TEXT)
    .setHeader('Access-Control-Allow-Origin', '*')
    .setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')
    .setHeader('Access-Control-Allow-Headers', 'Content-Type')
    .setHeader('Access-Control-Max-Age', '86400');
}
